# Import and export {}


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```



Katika ukurasa huu tunaelezea njia za kupata, kuagiza na kuhamisha faili: 

* Matumizi ya **rio** kifurushi kwa urahisi ku `import()` na `export()` aina nyingi za faili
* Matumizi ya **here** kifurushi kupata faili zinazohusiana na R project root - ili kuzuia matatizo kutoka kwa njia za faili ambazo ni maalum kwa kompyuta moja
* Matukio mahususi ya uingizaji, kama vile:  
  * Laha maalum ya Excel  
  * Messy headers and skipping rows  
  * Kutoka laha za Google  
  * Kutoka kwa data iliyowekwa kwenye tovuti 
  * Na APIs  
  * Kupakia faili ya *hivi karibuni*  
* Uingizaji wa data kwa mikono 
* Aina za faili maalum za R kama vile RDS na RData  
* Kusafirisha/kuhifadhi faili na viwanja  


<!-- ======================================================= -->
## Overview

Unapoingiza seti ya data katika R, kwa ujumla unaunda kipengee kipya cha *data frame* katika mazingira yako ya R na kukifafanua kama faili iliyoagizwa kutoka nje (kwa mfano, Excel, CSV, TSV, RDS) ambayo iko katika saraka za folda yako katika njia/anwani fulani ya faili.

Unaweza kuagiza/kusafirisha aina nyingi za faili, ikiwa ni pamoja na zile zilizoundwa na programu nyingine za takwimu (SAS, STATA, SPSS). Unaweza pia kuunganisha kwenye hifadhidata za uhusiano.

R hata ina fomati zake za data:

* Faili ya RDS (.rds) huhifadhi kitu kimoja cha R kama vile fremu ya data. Hizi ni muhimu kuhifadhi data iliyosafishwa, kwani hudumisha madarasa ya safu wima ya R. Soma zaidi katika [sehemu hii](#import_rds).    
*Faili ya RData (.Rdata) inaweza kutumika kuhifadhi vitu vingi, au hata nafasi kamili ya kazi ya R. Soma zaidi katika [sehemu hii](#import_rdata).  


<!-- ======================================================= -->
## The **rio** package {}  

Kifurushi cha R tunachopendekeza ni: **rio**. Jina "rio" ni ufupisho wa "R I/O" (input/output. 

Vitendakazi `import()` na `export()` inaweza kushughulikia aina nyingi za faili (k.m. .xlsx, .csv, .rds, .tsv). Unapotoa njia ya faili kwa mojawapo ya chaguo hizi za vitendakazi (ikijumuisha kiendelezi cha faili kama ".csv"), **rio** itasoma kiendelezi na kutumia zana sahihi kupakia au kupakua faili.


Njia mbadala ya kutumia **rio** ni kutumia vitendakazi kutoka kwa vifurushi vingine vingi, ambavyo kila moja ni maalum kwa aina ya faili. Kwa mfano, `read.csv()` (**base** R), `read.xlsx()` (**openxlsx** kifurushi), na `write_csv()` (**readr** pacakge), n.k. Hizi mbadala zinaweza kuwa ngumu kukumbuka, ilhali kutumia `import()` na `export()` kutoka **rio** ni rahisi.


Vitendakazi vya **rio** `import()` na `export()` hutumia kifurushi kinachofaa na chaguo la kukokotoa kwa faili fulani, kulingana na kiendelezi cha faili yake. Tazama mwisho wa ukurasa huu kwa jedwali kamili ambalo vifurushi/vitendakazi zake **rio** hutumia chinichini. Inaweza pia kutumika kuleta faili za STATA, SAS, na SPSS, kati ya aina nyingi za faili.

Import/export of shapefiles requires other packages, as detailed in the page on [GIS basics].    

Kupakia/Kupakua  faili za ramani kunahitaji vifurushi vingine, kama ilivyofafanuliwa kwenye ukurasa kwenye [misingi ya GIS].



## Kifurushi cha **here** {#here} 
Kifurushi **here** na kitendakazi chake `here()` hurahisisha kuambia R mahali pa kupata na kuhifadhi faili zako - kimsingi, huunda njia za faili.

Inatumika kwa kushirikiana na mradi wa R, **here** hukuruhusu kuelezea eneo la faili katika mradi wako wa R kuhusiana na *root directory* ya mradi wa R (folda ya kiwango cha juu). Hii ni muhimu wakati mradi wa R unaweza kushirikiwa au kufikiwa na watu/kompyuta nyingi. Huzuia matatizo kutokana na njia za kipekee za faili kwenye kompyuta tofauti (k.m. `"C:/Users/Laura/Documents..."` kwa "kuanzisha" njia ya faili mahali panapojulikana kwa watumiaji wote (msingi wa mradi wa R).



Hivi ndivyo `here()` inavyofanya kazi ndani ya mradi wa R:

* Wakati kifurushi cha **here** kinapopakiwa kwa mara ya kwanza ndani ya mradi wa R, huweka faili ndogo inayoitwa ".here" kwenye folda ya msingi ya mradi wako wa R kama "kigezo" au "nanga"

* Katika hati zako, kurejelea faili kwenye folda ndogo za mradi wa R, unatumia kazi `here()` kuunda njia ya faili *kuhusiana na nanga hiyo*
* Ili kuunda njia ya faili, andika majina ya folda zaidi ya mzizi, ndani ya nukuu, ikitenganishwa na koma, mwishowe kuishia na jina la faili na ugani wa faili kama inavyoonyeshwa hapa chini.
* `here()` njia za faili zinaweza kutumika kwa kupakia na kupakua.

Kwa mfano, hapa chini, chaguo za kukokotoa `import()` inatolewa kwa njia ya faili iliyoundwa na `hapa()`.  

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```


Msimbo `here("data", "linelists", "ebola_linelist.xlsx")` inatoa njia kamili ya faili ambayo ni *ya kipekee kwa kompyuta ya mtumiaji*:

```
"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"
```

Uzuri ni kwamba amri ya R inayotumia `here()` inaweza kuendeshwa kwa mafanikio kwenye kompyuta yoyote inayopata mradi wa R.

<span style="color: darkgreen;">**_TIP:_** Ikiwa huna uhakika ambapo mzizi wa ".here" umewekwa, endesha chaguo la kukokotoa `here()` kwa mabano tupu.</span>  

Soma zaidi kuhusu kifurushi cha **hapa** [kwenye kiungo hiki](https://here.r-lib.org/).  



<!-- ======================================================= -->
## File paths  

 
Wakati wa kupakia au kupakua data, lazima utoe njia ya faili. Unaweza kufanya hivyo kwa moja ya njia hizi tatu:
1) *Inapendekezwa:* toa njia ya faili "sawa na" na kifurushi cha **here**
2) Toa njia ya faili "kamili" / "kabisa".
3) Uchaguzi wa faili mwenyewe



### "Relative" file paths {.unnumbered}

Katika R, njia za faili "sawa" zinajumuisha njia ya faili *sawa na* mzizi wa mradi wa R. Huruhusu njia rahisi zaidi za faili zinazoweza kufanya kazi kwenye kompyuta tofauti (k.m. ikiwa mradi wa R uko kwenye hifadhi ya pamoja au unatumwa kwa barua pepe). Kama ilivyoelezwa [hapo juu](#here), njia za faili za jamaa zinawezeshwa na matumizi ya kifurushi cha **here**.


Mfano wa njia ya faili ya jamaa iliyoundwa na `here()` iko hapa chini. Tunachukulia kuwa kazi iko katika mradi wa R ambao una folda ndogo ya "data" na ndani ya folda hiyo "orodha za mstari", ambamo kuna faili ya .xlsx ya kuvutia. 

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```



### Njia za faili "kamili". {.unnumbered}  

Njia "kamili" za faili zinaweza kutolewa kwa utendaji kama vile `import()` lakini ni "tete" kwa kuwa ni za kipekee kwa kompyuta mahususi ya mtumiaji na kwa hivyo *haipendekezwi*.

Chini ni mfano wa njia kamili ya faili, ambapo katika kompyuta ya Laura kuna folda "uchambuzi", "data" ndogo ya folda na ndani ya folda ndogo ya "linelists", ambayo kuna faili ya .xlsx ya riba. .

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx")
```

Mambo machache ya kuzingatia kuhusu njia kamili za faili:

* **Epuka kutumia njia za faili kabisa** kwani zitavunjika ikiwa hati itaendeshwa kwenye kompyuta tofauti.
* Tumia mikwaju ya *mbele* (`/`), kama ilivyo kwenye mfano hapo juu (kumbuka: hii sio *SIO* chaguomsingi kwa njia za faili za Windows) 
* Njia za faili zinazoanza kwa kufyeka mara mbili (k.m. "//...") kuna uwezekano ** hazitatambuliwa na R** na zitaleta hitilafu. Fikiria kuhamishia kazi yako kwenye hifadhi ya "iliyopewa jina" au "iliyo na herufi" inayoanza na herufi (k.m. "J:" au "C:"). Tazama ukurasa kwenye [Maingiliano ya Saraka] kwa maelezo zaidi kuhusu suala hili. 

Hali moja ambapo njia kamili za faili zinaweza kufaa ni wakati unataka kuleta faili kutoka kwa hifadhi ya pamoja ambayo ina njia sawa ya faili kwa watumiaji wote.

<span style="color: darkgreen;">**_TIP:_** Ili kubadilisha kwa haraka `\` zote kuwa `/`, onyesha msimbo unaokuvutia, tumia Ctrl+f (katika Windows), chagua kisanduku cha chaguo "Katika uteuzi", kisha utumie utendakazi wa kubadilisha ili kuzibadilisha.</span>  



<!-- ======================================================= -->
### Chagua faili mwenyewe {.unnumbered}

Unaweza kuingiza data mwenyewe kupitia mojawapo ya njia hizi:

1) Kidirisha cha RStudio cha Mazingira, bofya "Import Dataset", na uchague aina ya data
2) Bonyeza Faili / Pakia seti ya data / (chagua aina ya data)
3) Ili kuchagua kwa mikono kwa msimbo ngumu, tumia amri ya *msingi R* `file.choose()` (ukiacha mabano tupu) ili kuanzisha **dirisha ibukizi** linalomruhusu mtumiaji kuchagua mwenyewe faili. kompyuta zao. Kwa mfano:

```{r import_choose, eval=F}
# Manual selection of a file. When this command is run, a POP-UP window will appear. 
# The file path selected will be supplied to the import() command.

my_data <- import(file.choose())
```

<span style="color: darkgreen;">**_TIP:_** **dirisha ibukizi** linaweza kuonekana NYUMA ya dirisha lako la RStudio.</span>



## Import data  


Kutumia `import()` kuleta seti za data ni rahisi sana. Toa tu njia ya faili (pamoja na jina la faili na ugani wa faili) katika nukuu. Ikiwa unatumia `here()` kuunda njia ya faili, fuata maagizo hapo juu. Ifuatayo ni mifano michache:

Kupakia faili ya csv ambayo iko kwenye "saraka yako ya kufanya kazi" au kwenye folda ya mizizi ya mradi wa R:

```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```

Kupakia laha la kwanza la kitabu cha kazi cha Excel ambacho kiko katika "data" na "orodha" ndogo za mradi wa R (njia ya faili iliyojengwa kwa kutumia `here()`):

```{r, eval=F}
linelist <- import(here("data", "linelists", "linelist_cleaned.xlsx"))
```


Kupakia dataseti (faili ya .rds) kwa kutumia njia ya faili kamili:

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```





### Specific Excel sheets {.unnumbered}

Kwa chaguo-msingi, ukitoa kitabu cha kazi cha Excel (.xlsx) ili `import()`, laha ya kwanza ya kitabu hicho itapakiwa Ikiwa unataka kuleta **laha** maalum, jumuisha jina la laha kwa hoja ya `which =`. Kwa mfano:

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```

Iwapo unatumia mbinu ya `here()` kutoa njia jamaa ya `import()`, bado unaweza kuonyesha laha mahususi kwa kuongeza hoja ya `which =` baada ya mabano ya kufunga ya chaguo za kukokotoa `here()`.

```{r import_sheet_here, eval=F}
# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package
linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```


Ili *kupakia* dataseti kutoka kwa R hadi laha mahususi ya Excel na kufanya kitabu kingine cha kazi cha Excel kibaki bila kubadilika, itabidi upakie, uhariri, na usafirishaji ukitumia kifurushi mbadala kilichoainishwa kwa madhumuni haya kama vile **openxlsx** . Tazama habari zaidi kwenye ukurasa kwenye [Maingiliano ya Saraka] au [kwenye ukurasa huu wa github](https://ycphs.github.io/openxlsx/).


Ikiwa kitabu chako cha kazi cha Excel ni .xlsb (kitabu cha kazi cha umbizo la binary) huenda usiweze kukipakia kwa kutumia **rio**. Fikiria kuihifadhi tena kama .xlsx, au kutumia kifurushi kama **readxlsb** ambacho kimeundwa kwa ajili ya [kusudi hili](https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html). 




<!-- ======================================================= -->
### Missing values {#import_missing .unnumbered} 

Unaweza kutaka kubainisha ni thamani gani katika dataseti zinazopaswa kuzingatiwa kuwa hazipo. Kama ilivyoelezwa kwenye ukurasa wa [Data inayokosekana], thamani katika R kwa data inayokosekana ni `NA`, lakini labda dataseti unayotaka kuleta hutumia 99, "Inakosa", au nafasi tupu ya herufi "" badala yake.

  
Tumia `na =` hoja ya `import()` na toa thamani ndani ya nukuu (hata kama ni nambari). Unaweza kubainisha thamani nyingi kwa kuzijumuisha ndani ya vekta, kwa kutumia `c()` kama inavyoonyeshwa hapa chini.

Hapa, thamani "99" katika mkusanyiko wa data ulioingizwa inachukuliwa kuwa haipo na kubadilishwa kuwa `NA` katika R. 

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

Here, any of the values "Missing", "" (empty cell), or " " (single space) in the imported dataset are converted to `NA` in R.  

Hapa, thamani zozote za "Haipo", "" (kisanduku tupu), au " " (nafasi moja) katika dataseti zilizopakiwa zinabadilishwa kuwa `NA` katika R.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```


<!-- ======================================================= -->
### Skip rows {.unnumbered} 

Wakati mwingine, unaweza kutaka kuepuka kupakia safu mlalo ya data. Unaweza kufanya hivi kwa hoja `ruka =` ikiwa unatumia `import()` kutoka **rio** kwenye faili ya .xlsx au .csv. Toa idadi ya safu mlalo unayotaka kuruka.

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # does not import header row
```

Kwa bahati mbaya `skip = ` inakubali thamani moja kamili pekee, *sio* masafa (k.m. "2:10" haifanyi kazi). Ili kuruka kupakia safu mlalo mahususi zisizofuatana kutoka juu, zingatia kupakia mara nyingi na kutumia `bind_rows()` kutoka **dplyr**. Tazama mfano hapa chini wa kuruka safu mlalo ya 2 pekee.


### Manage a second header row {.unnumbered}  

Wakati mwingine, data yako inaweza kuwa na safu mlalo *ya pili*, kwa mfano ikiwa ni safu mlalo ya "kamusi ya data" kama inavyoonyeshwa hapa chini. Hali hii inaweza kuwa ya shida kwa sababu inaweza kusababisha safu wima zote kuingizwa kama "tabia" ya darasa.


```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

 
Ufuatao ni mfano wa aina hii ya dataseti (na safu mlalo ya kwanza ikiwa kamusi ya data).

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### Remove the second header row {.unnumbered}  

To drop the second header row, you will likely need to import the data twice.  

1) Import the data in order to store the correct column names  
2) Import the data again, skipping the first *two* rows (header and second rows)  
3) Bind the correct names onto the reduced dataframe

The exact argument used to bind the correct column names depends on the type of data file (.csv, .tsv, .xlsx, etc.). This is because **rio** is using a different function for the different file types (see table above).  

**For Excel files:** (`col_names = `)  

```{r, eval=F}
# import first time; store the column names
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # save true column names

# import second time; skip row 2, and assign column names to argument col_names =
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**For CSV files:** (`col.names = `)  

```{r, eval=F}
# import first time; sotre column names
linelist_raw_names <- import("linelist_raw.csv") %>% names() # save true column names

# note argument for csv files is 'col.names = '
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Backup option** - changing column names as a separate command

```{r, eval=F}
# assign/overwrite headers using the base 'colnames()' function
colnames(linelist_raw) <- linelist_raw_names
```


#### Make a data dictionary {.unnumbered}  

Bonus! If you do have a second row that is a data dictionary, you can easily create a proper data dictionary from it. This tip is adapted from this [post](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/).  


```{r}
dict <- linelist_2headers %>%             # begin: linelist with dictionary as first row
  head(1) %>%                             # keep only column names and first dictionary row                
  pivot_longer(cols = everything(),       # pivot all columns to long format
               names_to = "Column",       # assign new column names
               values_to = "Description")
```


```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```



#### Combine the two header rows {.unnumbered}  

In some cases when your raw dataset has *two* header rows (or more specifically, the 2nd row of data is a secondary header), you may want to "combine" them or add the values in the second header row into the first header row.  

The command below will define the data frame's column names as the combination (pasting together) of the first (true) headers with the value immediately underneath (in the first row).  

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```



<!-- ======================================================= -->
### Google sheets {.unnumbered}

You can import data from an online Google spreadsheet with the **googlesheet4** package and by authenticating your access to the spreadsheet.  


```{r, eval=F}
pacman::p_load("googlesheets4")
```

Below, a demo Google sheet is imported and saved. This command may prompt confirmation of authentification of your Google account. Follow prompts and pop-ups in your internet browser to grant Tidyverse API packages permissions to edit, create, and delete your spreadsheets in Google Drive.  


The sheet below is "viewable for anyone with the link" and you can try to import it.  

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

The sheet can also be imported using only the sheet ID, a shorter part of the URL:  

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```


Another package, **googledrive** offers useful functions for writing, editing, and deleting Google sheets. For example, using the  `gs4_create()` and `sheet_write()` functions found in this package. 

Here are some other helpful online tutorials:  
[basic Google sheets importing tutorial](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)  
[more detailed tutorial](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)  
[interaction between the googlesheets4 and tidyverse](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)  




## Multiple files - import, export, split, combine  

See the page on [Iteration, loops, and lists] for examples of how to import and combine multiple files, or multiple Excel workbook files. That page also has examples on how to split a data frame into parts and export each one separately, or as named sheets in an Excel workbook.  




<!-- ======================================================= -->
## Import from Github {#import_github}

Importing data directly from Github into R can be very easy or can require a few steps - depending on the file type. Below are some approaches:  

### CSV files {.unnumbered}  

It can be easy to import a .csv file directly from Github into R with an R command.  

1) Go to the Github repo, locate the file of interest, and click on it  
3) Click on the "Raw" button (you will then see the "raw" csv data, as shown below)  
4) Copy the URL (web address)  
5) Place the URL in quotes within the `import()` R command  

```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### XLSX files {.unnumbered}  

You may not be able to view the "Raw" data for some files (e.g. .xlsx, .rds, .nwk, .shp)  

1) Go to the Github repo, locate the file of interest, and click on it  
2) Click the "Download" button, as shown below  
3) Save the file on your computer, and import it into R  


```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### Shapefiles {.unnumbered} 

Shapefiles have many sub-component files, each with a different file extention. One file will have the ".shp" extension, but others may have ".dbf", ".prj", etc.  To download a shapefile from Github, you will need to download each of the sub-component files individually, and save them in the *same* folder on your computer. In Github, click on each file individually and download them by clicking on the "Download" button.  

Once saved to your computer you can import the shapefile as shown in the [GIS basics] page using `st_read()` from the **sf** package. You only need to provide the filepath and name of the ".shp" file - as long as the other related files are within the same folder on your computer.  

Below, you can see how the shapefile "sle_adm3" consists of many files - each of which must be downloaded from Github.  

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```





<!-- ======================================================= -->
## Manual data entry {}

### Entry by rows {.unnumbered}  

Use the `tribble` function from the **tibble** package from the tidyverse ([online tibble reference](https://tibble.tidyverse.org/reference/tribble.html)).  
  
Note how column headers start with a *tilde* (`~`).  Also note that each column must contain only one class of data (character, numeric, etc.). You can use tabs, spacing, and new rows to make the data entry more intuitive and readable. Spaces do not matter between values, but each row is represented by a new line of code. For example:  

```{r import_manual_row}
# create the dataset manually by row
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

And now we display the new dataset:  

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_rows)
```


### Entry by columns {.unnumbered}  

Since a data frame consists of vectors (vertical columns), the **base** approach to manual dataframe creation in R expects you to define each column and then bind them together. This can be counter-intuitive in epidemiology, as we usually think about our data in rows (as above). 

```{r import_manual_col}
# define each vector (vertical column) separately, each with its own name
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

<span style="color: orange;">**_CAUTION:_** All vectors must be the same length (same number of values).</span>

The vectors can then be bound together using the function `data.frame()`:  

```{r}
# combine the columns into a data frame, by referencing the vector names
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

And now we display the new dataset:  

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_cols)
```




### Pasting from clipboard {.unnumbered}  

If you copy data from elsewhere and have it on your clipboard, you can try one of the two ways below:  

From the **clipr** package, you can use `read_clip_tbl()` to import as a data frame, or just just `read_clip()` to import as a character vector. In both cases, leave the parentheses empty.    

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # imports current clipboard as data frame
linelist <- clipr::read_clip()      # imports as character vector
```
You can also easily export to your system's clipboard with **clipr**. See the section below on Export.  


Alternatively, you can use the the `read.table()` function from **base** R with `file = "clipboard")` to import as a data frame:  

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # specify this as "clipboard"
  sep = "t",           # separator could be tab, or commas, etc.
  header=TRUE)         # if there is a header row
```






## Import most recent file  

Often you may receive daily updates to your datasets. In this case you will want to write code that imports the most recent file. Below we present two ways to approach this:  

* Selecting the file based on the date in the file name  
* Selecting the file based on file metadata (last modification)  


### Dates in file name {.unnumbered}  

This approach depends on three premises:  

1) You trust the dates in the file names  
2) The dates are numeric and appear in *generally* the same format (e.g. year then month then day)  
3) There are no other numbers in the file name  

We will explain each step, and then show you them combined at the end.  

First, use `dir()` from **base** R to extract just the file names for each file in the folder of interest. See the page on [Directory interactions] for more details about `dir()`. In this example, the folder of interest is the folder "linelists" within the folder "example" within "data" within the R project. 

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # get file names from folder
linelist_filenames                                              # print
```

Once you have this vector of names, you can extract the dates from them by applying `str_extract()` from **stringr** using this regular expression. It extracts any numbers in the file name (including any other characters in the middle such as dashes or slashes). You can read more about **stringr** in the [Strings and characters] page.  

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") # extract numbers and any characters in between
linelist_dates_raw  # print
```

Assuming the dates are written in generally the same date format (e.g. Year then Month then Day) and the years are 4-digits, you can use **lubridate**'s flexible conversion functions (`ymd()`, `dmy()`, or `mdy()`) to convert them to dates. For these functions, the dashes, spaces, or slashes do not matter, only the order of the numbers. Read more in the [Working with dates] page.  

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```


The **base** R function `which.max()` can then be used to return the index position (e.g. 1st, 2nd, 3rd, ...) of the maximum date value. The latest file is correctly identified as the 6th file - "case_linelist_2020-10-08.xlsx".  

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

If we condense all these commands, the complete code could look like below. Note that the `.` in the last line is a placeholder for the piped object at that point in the pipe sequence. At that point the value is simply the number 6. This is placed in double brackets to extract the 6th element of the vector of file names produced by `dir()`.    

```{r}
# load packages
pacman::p_load(
  tidyverse,         # data management
  stringr,           # work with strings/characters
  lubridate,         # work with dates
  rio,               # import / export
  here,              # relative file paths
  fs)                # directory interactions

# extract the file name of latest file
latest_file <- dir(here("data", "example", "linelists")) %>%  # file names from "linelists" sub-folder          
  str_extract("[0-9].*[0-9]") %>%                  # pull out dates (numbers)
  ymd() %>%                                        # convert numbers to dates (assuming year-month-day format)
  which.max() %>%                                  # get index of max date (latest file)
  dir(here("data", "example", "linelists"))[[.]]              # return the filename of latest linelist

latest_file  # print name of latest file
```

You can now use this name to finish the relative file path, with `here()`:  

```{r, eval=F}
here("data", "example", "linelists", latest_file) 
```

And you can now import the latest file:  

```{r, eval=F}
# import
import(here("data", "example", "linelists", latest_file)) # import 
```

 



### Use the file info {.unnumbered}  

If your files do not have dates in their names (or you do not trust those dates), you can try to extract the last modification date from the file metadata. Use functions from the package **fs** to examine the metadata information for each file, which includes the last modification time and the file path.  

Below, we provide the folder of interest to **fs**'s `dir_info()`. In this case, the folder of interest is in the R project in the folder "data", the sub-folder "example", and its sub-folder "linelists".  The result is a data frame with one line per file and columns for `modification_time`, `path`, etc. You can see a visual example of this in the page on [Directory interactions].    

We can sort this data frame of files by the column `modification_time`, and then keep only the top/latest row (file) with **base** R's `head()`. Then we can extract the file path of this latest file only with the **dplyr** function `pull()` on the column `path`. Finally we can pass this file path to `import()`. The imported file is saved as `latest_file`.  

```{r, eval=F}
latest_file <- dir_info(here("data", "example", "linelists")) %>%  # collect file info on all files in directory
  arrange(desc(modification_time)) %>%      # sort by modification time
  head(1) %>%                               # keep only the top (latest) file
  pull(path) %>%                            # extract only the file path
  import()                                  # import the file

```



<!-- ======================================================= -->
## APIs {#import_api}

An "Automated Programming Interface" (API) can be used to directly request data from a website. APIs are a set of rules that allow one software application to interact with another. The client (you) sends a "request" and receives a "response" containing content. The R packages **httr** and **jsonlite** can facilitate this process. 

Each API-enabled website will have its own documentation and specifics to become familiar with. Some sites are publicly available and can be accessed by anyone. Others, such as platforms with user IDs and credentials, require authentication to access their data. 

Needless to say, it is necessary to have an internet connection to import data via API. We will briefly give examples of use of APIs to import data, and link you to further resources.  

*Note: recall that data may be *posted* on a website without an API, which may be easier to retrieve. For example a posted CSV file may be accessible simply by providing the site URL to `import()` as described in the section on [importing from Github](#import_github).*  


### HTTP request {.unnumbered}  

The API exchange is most commonly done through an HTTP request. HTTP is Hypertext Transfer Protocol, and is the underlying format of a request/response between a client and a server. The exact input and output may vary depending on the type of API but the process is the same - a "Request" (often HTTP Request) from the user, often containing a query, followed by a "Response", containing status information about the request and possibly the requested content.  

Here are a few components of an *HTTP request*:  

* The URL of the API endpoint  
* The "Method" (or "Verb")  
* Headers  
* Body  

The HTTP request "method" is the action your want to perform. The two most common HTTP methods are `GET` and `POST` but others could include `PUT`, `DELETE`, `PATCH`, etc. When importing data into R it is most likely that you will use `GET`.  

After your request, your computer will receive a "response" in a format similar to what you sent, including URL, HTTP status (Status 200 is what you want!), file type, size, and the desired content. You will then need to parse this response and turn it into a workable data frame within your R environment.


### Packages {.unnumbered}  

The **httr** package works well for handling HTTP requests in R. It requires little prior knowledge of Web APIs and can be used by people less familiar with software development terminology. In addition, if the HTTP response is .json, you can use **jsonlite** to parse the response.  

```{r, eval=F}
# load packages
pacman::p_load(httr, jsonlite, tidyverse)
```


### Publicly-available data {.unnumbered}  

Below is an example of an HTTP request, borrowed from a tutorial from [the Trafford Data Lab](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs). This site has several other resources to learn and API exercises.

Scenario: We want to import a list of fast food outlets in the city of Trafford, UK. The data can be accessed from the API of the Food Standards Agency, which provides food hygiene rating data for the United Kingdom.  

Here are the parameters for our request:  

* HTTP verb: GET  
* API endpoint URL: http://api.ratings.food.gov.uk/Establishments  
* Selected parameters: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityId  
* Headers: “x-api-version”, 2  
* Data format(s): JSON, XML  
* Documentation: http://api.ratings.food.gov.uk/help  

The R code would be as follows:  

```{r, eval=F, warning=F, message=F}
# prepare the request
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# check for any server error ("200" is good!)
request$status_code

# submit the request, parse the response, and convert to a data frame
response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

You can now clean and use the `response` data frame, which contains one row per fast food facility.  


### Authentication required {.unnumbered}  

Some APIs require authentication - for you to prove who you are, so you can access restricted data. To import these data, you may need to first use a POST method to provide a username, password, or code. This will return an access token, that can be used for subsequent GET method requests to retrieve the desired data.  

Below is an example of querying data from *Go.Data*, which is an outbreak investigation tool. *Go.Data* uses an API for all interactions between the web front-end and smartphone applications used for data collection. *Go.Data* is used throughout the world. Because outbreak data are sensitive and you should only be able to access data for *your* outbreak, authentication is required.  

Below is some sample R code using **httr** and **jsonlite** for connecting to the *Go.Data* API to import data on contact follow-up from your outbreak.  


```{r, eval=F}
# set credentials for authorization
url <- "https://godatasampleURL.int/"           # valid Go.Data instance url
username <- "username"                          # valid Go.Data username 
password <- "password"                          # valid Go,Data password 
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # valid Go.Data outbreak ID

# get access token
url_request <- paste0(url,"api/oauth/token?access_token=123") # define base URL request

# prepare request
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # use saved username/password from above to authorize                               
    password = password),                                       
    encode = "json")

# execute request and parse response
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # flatten nested JSON
  glimpse()

# Save access token from response
access_token <- content$access_token    # save access token to allow subsequent API calls below

# import outbreak contacts
# Use the access token 
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # GET request
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # convert to text JSON

contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble
```

<span style="color: orange;">**_CAUTION:_** If you are importing large amounts of data from an API requiring authentication, it may time-out. To avoid this, retrieve access_token again before each API GET request and try using filters or limits in the query. </span> 

<span style="color: darkgreen;">**_TIP:_** The `fromJSON()` function in the **jsonlite** package does not fully un-nest the first time it's executed, so you will likely still have list items in your resulting tibble. You will need to further un-nest for certain variables; depending on how nested your .json is. To view more info on this, view the documentation for the **jsonlite** package, such as the [`flatten()` function](https://rdrr.io/cran/jsonlite/man/flatten.html). </span>


For more details, View documentation on [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), the [Contact Tracing] page or API tips on [Go.Data Github repository](https://worldhealthorganization.github.io/godata/api-docs)

You can read more about the *httr* package [here](https://httr.r-lib.org/articles/quickstart.html)  

This section was also informed by [this tutorial](https://www.dataquest.io/blog/r-api-tutorial/) and [this tutorial](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1). 




<!-- ======================================================= -->
## Export {}  

### With **rio** package {.unnumbered}
With **rio**, you can use the `export()` function in a very similar way to `import()`. First give the name of the R object you want to save (e.g. `linelist`) and then in quotes put the file path where you want to save the file, including the desired file name and file extension. For example:  

This saves the data frame `linelist` as an Excel workbook to the working directory/R project root folder:  

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # will save to working directory
```

You could save the same data frame as a csv file by changing the extension. For example, we also save it to a file path constructed with `here()`:  

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.csv"))
```


### To clipboard {.unnumbered}

To export a data frame to your computer's "clipboard" (to then paste into another software like Excel, Google Spreadsheets, etc.) you can use `write_clip()` from the **clipr** package. 

```{r, eval=F}
# export the linelist data frame to your system's clipboard
clipr::write_clip(linelist)
```




## RDS files {#import_rds}

Along with .csv, .xlsx, etc, you can also export/save R data frames as .rds files. This is a file format specific to R, and is very useful if you know you will work with the exported data again in R. 

The classes of columns are stored, so you don't have do to cleaning again when it is imported (with an Excel or even a CSV file this can be a headache!). It is also a smaller file, which is useful for export and import if your dataset is large.  

For example, if you work in an Epidemiology team and need to send files to a GIS team for mapping, and they use R as well, just send them the .rds file! Then all the column classes are retained and they have less work to do.  

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.rds"))
```



<!-- ======================================================= -->
## Rdata files and lists {#import_rdata}

`.Rdata` files can store multiple R objects - for example multiple data frames, model results, lists, etc. This can be very useful to consolidate or share a lot of your data for a given project.  

In the below example, multiple R objects are stored within the exported file "my_objects.Rdata":  

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Note: if you are trying to *import* a list, use `import_list()` from **rio** to import it with the complete original structure and contents.  

```{r, eval=F}
rio::import_list("my_list.Rdata")
```







<!-- ======================================================= -->
## Saving plots {} 

Instructions on how to save plots, such as those created by `ggplot()`, are discussed in depth in the [ggplot basics] page.  

In brief, run `ggsave("my_plot_filepath_and_name.png")` after printing your plot. You can either provide a saved plot object to the `plot = ` argument, or only specify the destination file path (with file extension) to save the most recently-displayed plot. You can also control the `width = `, `height = `, `units = `, and `dpi = `.  

How to save a network graph, such as a transmission tree, is addressed in the page on [Transmission chains]. 


<!-- ======================================================= -->
## Resources {} 

The [R Data Import/Export Manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html)  
[R 4 Data Science chapter on data import](https://r4ds.had.co.nz/data-import.html#data-import)  
[ggsave() documentation](https://ggplot2.tidyverse.org/reference/ggsave.html)  


Below is a table, taken from the **rio** online [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html). For each type of data it shows: the expected file extension, the package **rio** uses to import or export the data, and whether this functionality is included in the default installed version of **rio**.  



Format                     | Typical Extension | Import Package    | Export Package     | Installed by Default
---------------------------|-------------------|-------------------|--------------------|---------------------
Comma-separated data | .csv | data.table `fread()` | data.table |	Yes
Pipe-separated data |	.psv | data.table `fread()` | data.table | Yes
Tab-separated data| .tsv | data.table `fread()` | data.table | Yes
SAS | .sas7bdat | haven | haven | Yes
SPSS | .sav | haven | haven | Yes
Stata | .dta | haven | haven | Yes
SAS | XPORT | .xpt | haven | haven | Yes
SPSS Portable | .por | haven | | Yes
Excel | .xls | readxl | | Yes
Excel | .xlsx | readxl | openxlsx | Yes
R syntax | .R	| base | base | Yes
Saved R objects | .RData, .rda | base | base | Yes
Serialized R objects | .rds | base | base | Yes
Epiinfo | .rec | foreign | | Yes
Minitab | .mtp | foreign | | Yes
Systat | .syd |	foreign | | Yes
“XBASE” | database files | .dbf | foreign | foreign | Yes
Weka Attribute-Relation File Format | .arff | foreign | foreign | Yes
Data Interchange Format | .dif | utils | | Yes
Fortran data | no recognized extension | utils | | Yes
Fixed-width format data | .fwf | utils | utils | Yes
gzip comma-separated data | .csv.gz | utils | utils | Yes
CSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | No
EViews | .wf1 |hexView | | No
Feather R/Python interchange format | .feather | feather | feather | No
Fast Storage | .fst | fst |	fst | No
JSON | .json | jsonlite | jsonlite | No
Matlab | .mat | rmatio | rmatio | No
OpenDocument Spreadsheet | .ods | readODS | readODS | No
HTML Tables | .html | xml2 | xml2 | No
Shallow XML documents | .xml | xml2 | xml2 | No
YAML | .yml | yaml | yaml	| No
Clipboard	default is tsv | |  clipr | clipr | No



